#!/usr/bin/env node

/* eslint-disable no-use-before-define */
const yaml = require('js-yaml');
const path = require('path');
const fs = require('fs').promises;

const originalDebug = console.debug;
console.debug = function debug(...msgs) {
  if (process.env.VERBOSE) {
    originalDebug(...msgs);
  }
};

const fragmentPointerMatcher = /\*\{\{\s*([\w-_]+)\s*\}\}/;

const warningTemplate = (source) => '###################################################\n'
                                  + '#!! DO NOT EDIT THIS FILE DIRECTLY.\n'
                                  + '#\n'
                                  + `#!! This file was compiled from its source: ${source}\n`
                                  + '#!! To make changes to this file, edit its source and re-compile.\n'
                                  + '#!! See README for more information.\n'
                                  + '###################################################\n\n';

const baseDir = './.github/workflows';
const fragmentsCache = {};

async function loadJson(filename) {
  try {
    const fileContents = await fs.readFile(`${baseDir}/src/${filename}`, { encoding: 'utf-8' });
    return JSON.parse(fileContents);
  } catch (e) {
    throw new Error(`Error loading JSON for ${filename}: ${e.message}`);
  }
}

async function loadFragment(fragmentName) {
  const json = await loadJson(`fragments/${fragmentName}.json`);
  await processRoot(json);
  fragmentsCache[fragmentName] = json;
  return json;
}

async function getFragment(fragmentName) {
  if (fragmentsCache[fragmentName]) {
    return fragmentsCache[fragmentName];
  }

  const fragmentContents = await loadFragment(fragmentName);
  if (fragmentContents) {
    return fragmentContents;
  }

  throw new Error(`Fragment not found: ${fragmentName}`);
}

async function processStringKey(object, key) {
  const keyMatch = key.match(fragmentPointerMatcher);
  if (!keyMatch) {
    return; // don't do anything, this key will be processed normally.
  }

  const fragment = await getFragment(keyMatch[1]);
  delete object[key];
  Object.assign(object, fragment);
}

async function processStringValue(object, key) {
  const originalValue = object[key];
  const valueMatch = originalValue.match(fragmentPointerMatcher);
  if (!valueMatch) {
    object[key] = originalValue;
    return;
  }

  console.debug('loading fragment', valueMatch[1]);
  const fragment = await getFragment(valueMatch[1]);
  object[key] = fragment;
}

async function processArray(object, key) {
  const originalArray = object[key];
  const newArray = [];

  for (let index = 0; index < originalArray.length; index += 1) {
    await processAny(originalArray, index);
    const processedElement = originalArray[index];

    console.debug('processedElement', processedElement);
    if (Array.isArray(processedElement)) {
      await processAny(originalArray, index);
      newArray.push(...originalArray[index]);
    } else {
      newArray.push(processedElement);
    }
  }

  object[key] = newArray;
}

async function processObject(object, key) {
  for (const k of Object.keys(object[key])) {
    await processAny(object[key], k);
  }
}

function processAny(object, key) {
  console.debug('processing:', key);
  if (typeof key === 'string' && key.match(fragmentPointerMatcher)) {
    console.debug('key spread', key);
    return processStringKey(object, key);
  }

  const value = object[key];

  if (Array.isArray(value)) {
    console.debug('array', key);
    return processArray(object, key);
  }

  if (typeof value === 'string') {
    console.debug('string', key, value);
    return processStringValue(object, key);
  }

  if (typeof value === 'number' || value === undefined || value === null) {
    console.debug('pristine', key, value);
    // Value is already correct. Nothing to do.
    return null;
  }

  console.debug('object', key);
  return processObject(object, key);
}

async function processRoot(object) {
  if (object === null || object === undefined || typeof value === 'string' || typeof value === 'number') {
    // Scalar values. Do nothing.
    return;
  }

  if (Array.isArray(object)) {
    for (let index = 0; index < object.length; index += 1) {
      await processAny(object, index);
    }
    return;
  }

  for (const k of Object.keys(object)) {
    await processAny(object, k);
  }
}

async function run() {
  const sourceFiles = (await fs.readdir(`${baseDir}/src`)).filter((f) => path.extname(f) === '.json');

  for (const filename of sourceFiles) {
    const json = await loadJson(filename);
    await processRoot(json);

    const yamlContents = yaml.dump(json, {
      lineWidth: 160,
      noRefs: true,
      noCompatMode: true,
      forceQuotes: true,
    });

    const yamlWarning = warningTemplate(`src/${filename}`);
    const newFilename = filename.replace(/\.json$/, '.yml');
    const outputFile = `${baseDir}/${newFilename}`;
    const contents = `${yamlWarning}${yamlContents}`;

    const existingFileContents = await fs.readFile(outputFile, 'utf-8');
    if (existingFileContents !== contents) {
      await fs.writeFile(outputFile, contents, { flag: 'w' });
      console.info(`Wrote compiled yaml to ${newFilename}`);
    }
  }
}

run().catch((e) => {
  console.error(e);
  process.exit(1);
});
